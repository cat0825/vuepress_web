<template><div><h3 id="推理机制" tabindex="-1"><a class="header-anchor" href="#推理机制"><span>推理机制</span></a></h3>
<h4 id="传统推理方式" tabindex="-1"><a class="header-anchor" href="#传统推理方式"><span>传统推理方式：</span></a></h4>
<p>逐 token 生成，无法并行。</p>
<h4 id="过程建模两种方式" tabindex="-1"><a class="header-anchor" href="#过程建模两种方式"><span>过程建模两种方式：</span></a></h4>
<ol>
<li>矩阵-向量乘法：一个大矩阵（例如 <span v-pre class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>8192</mn><mo>×</mo><mn>8192</mn></mrow><annotation encoding="application/x-tex">8192 \times 8192</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">8192</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8192</span></span></span></span>）乘以一个向量，得到另一个向量。</li>
<li>Attention 计算：利用 KV-cache 进行推理。</li>
</ol>
<h4 id="瓶颈分析-浮点运算的主要来源" tabindex="-1"><a class="header-anchor" href="#瓶颈分析-浮点运算的主要来源"><span>瓶颈分析：浮点运算的主要来源</span></a></h4>
<ul>
<li>矩阵-向量乘法对每个矩阵元素执行一次乘加运算（2 FLOPs）。</li>
<li>Attention 对每个 key 执行一次乘加，对每个 value 执行一次乘加。</li>
</ul>
<h3 id="时延计算" tabindex="-1"><a class="header-anchor" href="#时延计算"><span>时延计算</span></a></h3>
<h4 id="计算一个-token-所需要的数据量" tabindex="-1"><a class="header-anchor" href="#计算一个-token-所需要的数据量"><span>计算一个 token 所需要的数据量</span></a></h4>
<p>在 NVIDIA RTX 4090（1008 GB/s）上，14.2GB (fp16) 需要约 14.1ms 读取，因此可以预期对于位置靠前的 token，每个 token 大约需要 14.1ms（KV-cache 影响可以忽略不计）。如果使用 8bit 权重，需要读取 7.1GB，这需要大约 7.0ms。这些都是理论下限，代表了生成每个 token 的最小可能时间。</p>
<p>参考来源：《LLM inference speed of light》</p>
<p>通俗来说，模型的预测时间可以近似理解为：</p>
<p v-pre class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>y</mi><mo>=</mo><mi>k</mi><mo>⋅</mo><mi>x</mi><mo>+</mo><mi>b</mi></mrow><annotation encoding="application/x-tex">y = k \cdot x + b
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span></span></p>
<p>其中 <span v-pre class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 是首个 token 的耗时，<span v-pre class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 是后续每个 token 的耗时，<span v-pre class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span> 是生成 token 的总数量。更具体的，<span v-pre class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">b</span></span></span></span> 会是 <span v-pre class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 的十几倍或更多，和 prompt 的长度几乎呈正相关。这个耗时的近似估算和 KV-cache 机制有关，不熟悉的可以自行搜索。</p>
<p>这也就是为什么众人都知 CoT 效果好，众人又都不使用 CoT（但是现在 o1、R1 的大模型推理增强还是需要很多 CoT 数据的），因为我们可以几乎下断言“模型的生成速度和生成 token 数量呈正相关”，而 CoT 恰恰又引入了大量的生成 token。</p>
<h3 id="推理-tps-计算" tabindex="-1"><a class="header-anchor" href="#推理-tps-计算"><span>推理 TPS 计算</span></a></h3>
<h4 id="如何计算-tps" tabindex="-1"><a class="header-anchor" href="#如何计算-tps"><span>如何计算 TPS？</span></a></h4>
<p>部署 LLM 时，每秒生成的 token 数量 TPS（Tokens Per Second）是衡量推理性能的重要指标：</p>
<p v-pre class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mi>P</mi><mi>S</mi><mo>=</mo><mfrac><mtext>生成的 token 总数</mtext><mtext>总延迟时间（秒）</mtext></mfrac></mrow><annotation encoding="application/x-tex">TPS = \frac{\text{生成的 token 总数}}{\text{总延迟时间（秒）}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">TPS</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0574em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">总延迟时间（秒）</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">生成的</span><span class="mord"> token </span><span class="mord cjk_fallback">总数</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>总延迟时间包括两个阶段：</p>
<ul>
<li>TTFT（Time To First Token）：从输入到生成第一个 token 的延迟时间，主要受 prompt 长度和模型结构影响，也就是在 Prefilling 阶段。</li>
<li>TPOT（Time Per Output Token）：生成每个后续 token 所需的平均时间，也就是在 Decoding 阶段。</li>
</ul>
<p>总延迟可表示为：</p>
<p v-pre class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>Latency</mtext><mo>=</mo><mtext>TTFT</mtext><mo>+</mo><mtext>TPOT</mtext><mo>×</mo><mtext>输出 token 数量</mtext></mrow><annotation encoding="application/x-tex">\text{Latency} = \text{TTFT} + \text{TPOT} \times \text{输出 token 数量}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">Latency</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord text"><span class="mord">TTFT</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord text"><span class="mord">TPOT</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord text"><span class="mord cjk_fallback">输出</span><span class="mord"> token </span><span class="mord cjk_fallback">数量</span></span></span></span></span></span></p>
<p>所以 TPS 可以表示为：</p>
<p v-pre class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>T</mi><mi>P</mi><mi>S</mi><mo>=</mo><mfrac><mtext>输出 token 数量</mtext><mrow><mtext>TTFT</mtext><mo>+</mo><mtext>TPOT</mtext><mo>×</mo><mtext>输出 token 数量</mtext></mrow></mfrac></mrow><annotation encoding="application/x-tex">TPS = \frac{\text{输出 token 数量}}{\text{TTFT} + \text{TPOT} \times \text{输出 token 数量}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">TPS</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1408em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord">TTFT</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord text"><span class="mord">TPOT</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord text"><span class="mord cjk_fallback">输出</span><span class="mord"> token </span><span class="mord cjk_fallback">数量</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">输出</span><span class="mord"> token </span><span class="mord cjk_fallback">数量</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<h3 id="tps-估算方法" tabindex="-1"><a class="header-anchor" href="#tps-估算方法"><span>TPS 估算方法</span></a></h3>
<ol>
<li>
<p>确定模型参数量：<span v-pre class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">X B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">XB</span></span></span></span></p>
</li>
<li>
<p>计算 Prefilling 阶段的 FLOPs：</p>
<p v-pre class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>FLOPs prefill</mtext><mo>=</mo><mn>2</mn><mo>×</mo><mtext>Batch Size</mtext><mo>×</mo><mtext>Prompt Length</mtext><mo>×</mo><mtext>模型参数量</mtext></mrow><annotation encoding="application/x-tex">\text{FLOPs prefill} = 2 \times \text{Batch Size} \times \text{Prompt Length} \times \text{模型参数量}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">FLOPs prefill</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord text"><span class="mord">Batch Size</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">Prompt Length</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">模型参数量</span></span></span></span></span></span></p>
</li>
<li>
<p>计算 Decoding 阶段的 FLOPs：
使用公式：</p>
<p v-pre class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>FLOPs decoding</mtext><mo>=</mo><mn>2</mn><mo>×</mo><mtext>Batch size</mtext><mo>×</mo><mtext>Completion Size</mtext><mo>×</mo><mtext>模型参数量</mtext></mrow><annotation encoding="application/x-tex">\text{FLOPs decoding} = 2 \times \text{Batch size} \times \text{Completion Size} \times \text{模型参数量}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">FLOPs decoding</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7278em;vertical-align:-0.0833em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord text"><span class="mord">Batch size</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord text"><span class="mord">Completion Size</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">模型参数量</span></span></span></span></span></span></p>
</li>
</ol>
<p>通过以上分析，我们可以更好地理解推理过程中各个阶段的性能瓶颈，并针对性地进行优化，以提升模型的推理效率。</p>
</div></template>


