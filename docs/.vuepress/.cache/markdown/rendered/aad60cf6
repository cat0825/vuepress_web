{"content":"<h2 id=\"元数据\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#元数据\"><span>元数据</span></a></h2>\n<ul>\n<li><strong>分类</strong>：自然语言处理（NLP）</li>\n<li><strong>标签</strong>：BPE、分词算法、子词编码、自然语言处理、优化</li>\n<li><strong>日期</strong>：2025年4月1日</li>\n</ul>\n<hr>\n<h2 id=\"核心观点概述\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#核心观点概述\"><span>核心观点概述</span></a></h2>\n<p>Byte Pair Encoding (BPE) 是一种常见的子词分词算法，通过逐步合并频率最高的字符对，生成一个高效的子词词表。它被广泛用于自然语言处理（NLP）任务中，尤其是在神经机器翻译（NMT）中，用以解决稀有词问题。</p>\n<p>💡 <strong>启发点</strong>：BPE通过贪婪算法逐步构建子词表，能够在词汇表大小和编码效率之间取得平衡。</p>\n<hr>\n<h2 id=\"重点内容提取\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#重点内容提取\"><span>重点内容提取</span></a></h2>\n<h3 id=\"bpe的核心思想\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#bpe的核心思想\"><span>## BPE的核心思想</span></a></h3>\n<ul>\n<li>BPE从一个基础的小型词表出发，不断合并频率最高的字符对，逐步生成新的子词单元。</li>\n<li>其目标是在子词粒度和词汇表大小之间找到平衡，使得模型既能高效编码，又能处理稀有词。</li>\n</ul>\n<h3 id=\"bpe的操作步骤\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#bpe的操作步骤\"><span>## BPE的操作步骤</span></a></h3>\n<ol>\n<li><strong>✅ 准备基础词表</strong>：例如英文中包含26个字母及符号（如 <code v-pre>_</code> 表示单词结尾）。</li>\n<li><strong>⚠️ 拆分语料为最小单元</strong>：将训练语料中的单词拆解为单个字符。</li>\n<li><strong>❗️ 统计频率并合并</strong>：找到语料中频率最高的相邻字符对，并将其合并为新的子词。</li>\n<li><strong>重复迭代</strong>：直到达到预设的子词表大小或频率阈值。</li>\n</ol>\n<hr>\n<h3 id=\"示例-从语料库中生成子词表\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#示例-从语料库中生成子词表\"><span>## 示例：从语料库中生成子词表</span></a></h3>\n<p>以下是一个简单的BPE操作示例。</p>\n<h4 id=\"初始语料库-带频次\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#初始语料库-带频次\"><span>初始语料库（带频次）</span></a></h4>\n<table>\n<thead>\n<tr>\n<th>词频</th>\n<th>单词</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>[5]</td>\n<td>low_</td>\n</tr>\n<tr>\n<td>[2]</td>\n<td>lowest_</td>\n</tr>\n<tr>\n<td>[6]</td>\n<td>newer_</td>\n</tr>\n<tr>\n<td>[3]</td>\n<td>wider_</td>\n</tr>\n<tr>\n<td>[2]</td>\n<td>new_</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"基础字符频次统计\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#基础字符频次统计\"><span>基础字符频次统计</span></a></h4>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>频次</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code v-pre>_</code></td>\n<td>18</td>\n</tr>\n<tr>\n<td><code v-pre>d</code></td>\n<td>3</td>\n</tr>\n<tr>\n<td><code v-pre>e</code></td>\n<td>19</td>\n</tr>\n<tr>\n<td><code v-pre>i</code></td>\n<td>3</td>\n</tr>\n<tr>\n<td><code v-pre>l</code></td>\n<td>7</td>\n</tr>\n<tr>\n<td><code v-pre>n</code></td>\n<td>8</td>\n</tr>\n<tr>\n<td><code v-pre>o</code></td>\n<td>7</td>\n</tr>\n<tr>\n<td><code v-pre>r</code></td>\n<td>9</td>\n</tr>\n<tr>\n<td><code v-pre>s</code></td>\n<td>2</td>\n</tr>\n<tr>\n<td><code v-pre>t</code></td>\n<td>2</td>\n</tr>\n<tr>\n<td><code v-pre>w</code></td>\n<td>22</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"第一次迭代-合并频率最高的字符对\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#第一次迭代-合并频率最高的字符对\"><span>第一次迭代：合并频率最高的字符对</span></a></h4>\n<ul>\n<li>合并 <code v-pre>r</code> 和 <code v-pre>_</code>，形成新子词 <code v-pre>r_</code>，更新后的频次为9。</li>\n<li>更新后的字符频次表：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>频次</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code v-pre>_</code></td>\n<td>9</td>\n</tr>\n<tr>\n<td><code v-pre>d</code></td>\n<td>3</td>\n</tr>\n<tr>\n<td><code v-pre>e</code></td>\n<td>19</td>\n</tr>\n<tr>\n<td><code v-pre>i</code></td>\n<td>3</td>\n</tr>\n<tr>\n<td><code v-pre>l</code></td>\n<td>7</td>\n</tr>\n<tr>\n<td><code v-pre>n</code></td>\n<td>8</td>\n</tr>\n<tr>\n<td><code v-pre>o</code></td>\n<td>7</td>\n</tr>\n<tr>\n<td><code v-pre>r</code></td>\n<td>0</td>\n</tr>\n<tr>\n<td><code v-pre>s</code></td>\n<td>2</td>\n</tr>\n<tr>\n<td><code v-pre>t</code></td>\n<td>2</td>\n</tr>\n<tr>\n<td><code v-pre>w</code></td>\n<td>22</td>\n</tr>\n<tr>\n<td><code v-pre>r_</code></td>\n<td>9</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"优缺点分析\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#优缺点分析\"><span>## 优缺点分析</span></a></h3>\n<ul>\n<li><strong>优点</strong>：\n<ul>\n<li>高效平衡了词汇表大小和编码步数。</li>\n<li>能够处理稀有词，避免OOV（Out of Vocabulary）问题。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>：\n<ul>\n<li>基于贪婪算法，无法生成带概率的多种分词结果。</li>\n<li>解码时可能存在歧义问题，例如同一输入可对应多种分词方式。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"常见错误与注意事项\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#常见错误与注意事项\"><span>常见错误与注意事项</span></a></h2>\n<p>⚠️ <strong>分词歧义问题</strong>：例如，&quot;Hello World&quot; 的分词结果可能出现多种形式，如 &quot;Hell/o/world&quot; 或 &quot;He/llo/world&quot;。</p>\n<p>⚠️ <strong>贪婪算法局限性</strong>：BPE仅考虑当前最优合并对，可能错过全局最优解。</p>\n<hr>\n<h2 id=\"行动清单\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#行动清单\"><span>行动清单</span></a></h2>\n<ul class=\"task-list-container\">\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" id=\"task-item-0\" checked=\"checked\" disabled=\"disabled\"><label class=\"task-list-item-label\" for=\"task-item-0\"> 实现一个简单的BPE算法，用于小型语料库测试。</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" id=\"task-item-1\" checked=\"checked\" disabled=\"disabled\"><label class=\"task-list-item-label\" for=\"task-item-1\"> 探索不同BPE参数（如词汇表大小）对模型性能的影响。</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" id=\"task-item-2\" checked=\"checked\" disabled=\"disabled\"><label class=\"task-list-item-label\" for=\"task-item-2\"> 比较BPE与其他分词方法（如WordPiece）的实际效果。</label></li>\n</ul>\n<hr>\n<h2 id=\"思考-延伸问题\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#思考-延伸问题\"><span>[思考] 延伸问题</span></a></h2>\n<ol>\n<li>如何改进BPE算法，使其支持概率分词？</li>\n<li>在多语言模型中，BPE如何适配不同语言的特性？\n<ol>\n<li>\n<ul>\n<li>任务是跨语言迁移/翻译 → 建议 <strong>共享 BPE + 语言前缀</strong></li>\n</ul>\n</li>\n<li>如果是低资源语言建模 → 考虑 <strong>独立子词表</strong> 或 BBPE 分配资源更公平</li>\n</ol>\n</li>\n<li>以结合深度学习技术优化BPE的子词选择过程？</li>\n</ol>\n<hr>\n<blockquote>\n<p><strong>来源</strong>：本文内容摘自论文《Neural Machine Translation of Rare Words with Subword Units》，链接：<a href=\"https://arxiv.org/pdf/1508.07909\" target=\"_blank\" rel=\"noopener noreferrer\">https://arxiv.org/pdf/1508.07909</a></p>\n</blockquote>\n","env":{"base":"/","filePath":"/Users/qianyuhe/Desktop/my-project/docs/notes_bak/大语言模型学习/分词/使用Byte Pair Encoding (BPE)优化子词分词的技巧与实践.md","filePathRelative":"notes_bak/大语言模型学习/分词/使用Byte Pair Encoding (BPE)优化子词分词的技巧与实践.md","frontmatter":{"dg-publish":true,"tags":["NLP"],"title":"使用Byte Pair Encoding (BPE)优化子词分词的技巧与实践","dg-permalink":"/大语言模型学习/分词/BPE","permalink":"/大语言模型学习/分词/BPE/","dgPassFrontmatter":true,"noteIcon":null,"created":"2025-03-27T01:54:11.996Z","updated":"2025-04-13T09:21:31.527Z","createTime":"2025/05/13 17:33:52"},"sfcBlocks":{"template":{"type":"template","content":"<template><h2 id=\"元数据\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#元数据\"><span>元数据</span></a></h2>\n<ul>\n<li><strong>分类</strong>：自然语言处理（NLP）</li>\n<li><strong>标签</strong>：BPE、分词算法、子词编码、自然语言处理、优化</li>\n<li><strong>日期</strong>：2025年4月1日</li>\n</ul>\n<hr>\n<h2 id=\"核心观点概述\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#核心观点概述\"><span>核心观点概述</span></a></h2>\n<p>Byte Pair Encoding (BPE) 是一种常见的子词分词算法，通过逐步合并频率最高的字符对，生成一个高效的子词词表。它被广泛用于自然语言处理（NLP）任务中，尤其是在神经机器翻译（NMT）中，用以解决稀有词问题。</p>\n<p>💡 <strong>启发点</strong>：BPE通过贪婪算法逐步构建子词表，能够在词汇表大小和编码效率之间取得平衡。</p>\n<hr>\n<h2 id=\"重点内容提取\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#重点内容提取\"><span>重点内容提取</span></a></h2>\n<h3 id=\"bpe的核心思想\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#bpe的核心思想\"><span>## BPE的核心思想</span></a></h3>\n<ul>\n<li>BPE从一个基础的小型词表出发，不断合并频率最高的字符对，逐步生成新的子词单元。</li>\n<li>其目标是在子词粒度和词汇表大小之间找到平衡，使得模型既能高效编码，又能处理稀有词。</li>\n</ul>\n<h3 id=\"bpe的操作步骤\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#bpe的操作步骤\"><span>## BPE的操作步骤</span></a></h3>\n<ol>\n<li><strong>✅ 准备基础词表</strong>：例如英文中包含26个字母及符号（如 <code v-pre>_</code> 表示单词结尾）。</li>\n<li><strong>⚠️ 拆分语料为最小单元</strong>：将训练语料中的单词拆解为单个字符。</li>\n<li><strong>❗️ 统计频率并合并</strong>：找到语料中频率最高的相邻字符对，并将其合并为新的子词。</li>\n<li><strong>重复迭代</strong>：直到达到预设的子词表大小或频率阈值。</li>\n</ol>\n<hr>\n<h3 id=\"示例-从语料库中生成子词表\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#示例-从语料库中生成子词表\"><span>## 示例：从语料库中生成子词表</span></a></h3>\n<p>以下是一个简单的BPE操作示例。</p>\n<h4 id=\"初始语料库-带频次\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#初始语料库-带频次\"><span>初始语料库（带频次）</span></a></h4>\n<table>\n<thead>\n<tr>\n<th>词频</th>\n<th>单词</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>[5]</td>\n<td>low_</td>\n</tr>\n<tr>\n<td>[2]</td>\n<td>lowest_</td>\n</tr>\n<tr>\n<td>[6]</td>\n<td>newer_</td>\n</tr>\n<tr>\n<td>[3]</td>\n<td>wider_</td>\n</tr>\n<tr>\n<td>[2]</td>\n<td>new_</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"基础字符频次统计\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#基础字符频次统计\"><span>基础字符频次统计</span></a></h4>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>频次</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code v-pre>_</code></td>\n<td>18</td>\n</tr>\n<tr>\n<td><code v-pre>d</code></td>\n<td>3</td>\n</tr>\n<tr>\n<td><code v-pre>e</code></td>\n<td>19</td>\n</tr>\n<tr>\n<td><code v-pre>i</code></td>\n<td>3</td>\n</tr>\n<tr>\n<td><code v-pre>l</code></td>\n<td>7</td>\n</tr>\n<tr>\n<td><code v-pre>n</code></td>\n<td>8</td>\n</tr>\n<tr>\n<td><code v-pre>o</code></td>\n<td>7</td>\n</tr>\n<tr>\n<td><code v-pre>r</code></td>\n<td>9</td>\n</tr>\n<tr>\n<td><code v-pre>s</code></td>\n<td>2</td>\n</tr>\n<tr>\n<td><code v-pre>t</code></td>\n<td>2</td>\n</tr>\n<tr>\n<td><code v-pre>w</code></td>\n<td>22</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"第一次迭代-合并频率最高的字符对\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#第一次迭代-合并频率最高的字符对\"><span>第一次迭代：合并频率最高的字符对</span></a></h4>\n<ul>\n<li>合并 <code v-pre>r</code> 和 <code v-pre>_</code>，形成新子词 <code v-pre>r_</code>，更新后的频次为9。</li>\n<li>更新后的字符频次表：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>频次</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code v-pre>_</code></td>\n<td>9</td>\n</tr>\n<tr>\n<td><code v-pre>d</code></td>\n<td>3</td>\n</tr>\n<tr>\n<td><code v-pre>e</code></td>\n<td>19</td>\n</tr>\n<tr>\n<td><code v-pre>i</code></td>\n<td>3</td>\n</tr>\n<tr>\n<td><code v-pre>l</code></td>\n<td>7</td>\n</tr>\n<tr>\n<td><code v-pre>n</code></td>\n<td>8</td>\n</tr>\n<tr>\n<td><code v-pre>o</code></td>\n<td>7</td>\n</tr>\n<tr>\n<td><code v-pre>r</code></td>\n<td>0</td>\n</tr>\n<tr>\n<td><code v-pre>s</code></td>\n<td>2</td>\n</tr>\n<tr>\n<td><code v-pre>t</code></td>\n<td>2</td>\n</tr>\n<tr>\n<td><code v-pre>w</code></td>\n<td>22</td>\n</tr>\n<tr>\n<td><code v-pre>r_</code></td>\n<td>9</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"优缺点分析\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#优缺点分析\"><span>## 优缺点分析</span></a></h3>\n<ul>\n<li><strong>优点</strong>：\n<ul>\n<li>高效平衡了词汇表大小和编码步数。</li>\n<li>能够处理稀有词，避免OOV（Out of Vocabulary）问题。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>：\n<ul>\n<li>基于贪婪算法，无法生成带概率的多种分词结果。</li>\n<li>解码时可能存在歧义问题，例如同一输入可对应多种分词方式。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"常见错误与注意事项\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#常见错误与注意事项\"><span>常见错误与注意事项</span></a></h2>\n<p>⚠️ <strong>分词歧义问题</strong>：例如，&quot;Hello World&quot; 的分词结果可能出现多种形式，如 &quot;Hell/o/world&quot; 或 &quot;He/llo/world&quot;。</p>\n<p>⚠️ <strong>贪婪算法局限性</strong>：BPE仅考虑当前最优合并对，可能错过全局最优解。</p>\n<hr>\n<h2 id=\"行动清单\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#行动清单\"><span>行动清单</span></a></h2>\n<ul class=\"task-list-container\">\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" id=\"task-item-0\" checked=\"checked\" disabled=\"disabled\"><label class=\"task-list-item-label\" for=\"task-item-0\"> 实现一个简单的BPE算法，用于小型语料库测试。</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" id=\"task-item-1\" checked=\"checked\" disabled=\"disabled\"><label class=\"task-list-item-label\" for=\"task-item-1\"> 探索不同BPE参数（如词汇表大小）对模型性能的影响。</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" id=\"task-item-2\" checked=\"checked\" disabled=\"disabled\"><label class=\"task-list-item-label\" for=\"task-item-2\"> 比较BPE与其他分词方法（如WordPiece）的实际效果。</label></li>\n</ul>\n<hr>\n<h2 id=\"思考-延伸问题\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#思考-延伸问题\"><span>[思考] 延伸问题</span></a></h2>\n<ol>\n<li>如何改进BPE算法，使其支持概率分词？</li>\n<li>在多语言模型中，BPE如何适配不同语言的特性？\n<ol>\n<li>\n<ul>\n<li>任务是跨语言迁移/翻译 → 建议 <strong>共享 BPE + 语言前缀</strong></li>\n</ul>\n</li>\n<li>如果是低资源语言建模 → 考虑 <strong>独立子词表</strong> 或 BBPE 分配资源更公平</li>\n</ol>\n</li>\n<li>以结合深度学习技术优化BPE的子词选择过程？</li>\n</ol>\n<hr>\n<blockquote>\n<p><strong>来源</strong>：本文内容摘自论文《Neural Machine Translation of Rare Words with Subword Units》，链接：<a href=\"https://arxiv.org/pdf/1508.07909\" target=\"_blank\" rel=\"noopener noreferrer\">https://arxiv.org/pdf/1508.07909</a></p>\n</blockquote>\n</template>","contentStripped":"<h2 id=\"元数据\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#元数据\"><span>元数据</span></a></h2>\n<ul>\n<li><strong>分类</strong>：自然语言处理（NLP）</li>\n<li><strong>标签</strong>：BPE、分词算法、子词编码、自然语言处理、优化</li>\n<li><strong>日期</strong>：2025年4月1日</li>\n</ul>\n<hr>\n<h2 id=\"核心观点概述\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#核心观点概述\"><span>核心观点概述</span></a></h2>\n<p>Byte Pair Encoding (BPE) 是一种常见的子词分词算法，通过逐步合并频率最高的字符对，生成一个高效的子词词表。它被广泛用于自然语言处理（NLP）任务中，尤其是在神经机器翻译（NMT）中，用以解决稀有词问题。</p>\n<p>💡 <strong>启发点</strong>：BPE通过贪婪算法逐步构建子词表，能够在词汇表大小和编码效率之间取得平衡。</p>\n<hr>\n<h2 id=\"重点内容提取\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#重点内容提取\"><span>重点内容提取</span></a></h2>\n<h3 id=\"bpe的核心思想\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#bpe的核心思想\"><span>## BPE的核心思想</span></a></h3>\n<ul>\n<li>BPE从一个基础的小型词表出发，不断合并频率最高的字符对，逐步生成新的子词单元。</li>\n<li>其目标是在子词粒度和词汇表大小之间找到平衡，使得模型既能高效编码，又能处理稀有词。</li>\n</ul>\n<h3 id=\"bpe的操作步骤\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#bpe的操作步骤\"><span>## BPE的操作步骤</span></a></h3>\n<ol>\n<li><strong>✅ 准备基础词表</strong>：例如英文中包含26个字母及符号（如 <code v-pre>_</code> 表示单词结尾）。</li>\n<li><strong>⚠️ 拆分语料为最小单元</strong>：将训练语料中的单词拆解为单个字符。</li>\n<li><strong>❗️ 统计频率并合并</strong>：找到语料中频率最高的相邻字符对，并将其合并为新的子词。</li>\n<li><strong>重复迭代</strong>：直到达到预设的子词表大小或频率阈值。</li>\n</ol>\n<hr>\n<h3 id=\"示例-从语料库中生成子词表\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#示例-从语料库中生成子词表\"><span>## 示例：从语料库中生成子词表</span></a></h3>\n<p>以下是一个简单的BPE操作示例。</p>\n<h4 id=\"初始语料库-带频次\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#初始语料库-带频次\"><span>初始语料库（带频次）</span></a></h4>\n<table>\n<thead>\n<tr>\n<th>词频</th>\n<th>单词</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>[5]</td>\n<td>low_</td>\n</tr>\n<tr>\n<td>[2]</td>\n<td>lowest_</td>\n</tr>\n<tr>\n<td>[6]</td>\n<td>newer_</td>\n</tr>\n<tr>\n<td>[3]</td>\n<td>wider_</td>\n</tr>\n<tr>\n<td>[2]</td>\n<td>new_</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"基础字符频次统计\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#基础字符频次统计\"><span>基础字符频次统计</span></a></h4>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>频次</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code v-pre>_</code></td>\n<td>18</td>\n</tr>\n<tr>\n<td><code v-pre>d</code></td>\n<td>3</td>\n</tr>\n<tr>\n<td><code v-pre>e</code></td>\n<td>19</td>\n</tr>\n<tr>\n<td><code v-pre>i</code></td>\n<td>3</td>\n</tr>\n<tr>\n<td><code v-pre>l</code></td>\n<td>7</td>\n</tr>\n<tr>\n<td><code v-pre>n</code></td>\n<td>8</td>\n</tr>\n<tr>\n<td><code v-pre>o</code></td>\n<td>7</td>\n</tr>\n<tr>\n<td><code v-pre>r</code></td>\n<td>9</td>\n</tr>\n<tr>\n<td><code v-pre>s</code></td>\n<td>2</td>\n</tr>\n<tr>\n<td><code v-pre>t</code></td>\n<td>2</td>\n</tr>\n<tr>\n<td><code v-pre>w</code></td>\n<td>22</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"第一次迭代-合并频率最高的字符对\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#第一次迭代-合并频率最高的字符对\"><span>第一次迭代：合并频率最高的字符对</span></a></h4>\n<ul>\n<li>合并 <code v-pre>r</code> 和 <code v-pre>_</code>，形成新子词 <code v-pre>r_</code>，更新后的频次为9。</li>\n<li>更新后的字符频次表：</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th>频次</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code v-pre>_</code></td>\n<td>9</td>\n</tr>\n<tr>\n<td><code v-pre>d</code></td>\n<td>3</td>\n</tr>\n<tr>\n<td><code v-pre>e</code></td>\n<td>19</td>\n</tr>\n<tr>\n<td><code v-pre>i</code></td>\n<td>3</td>\n</tr>\n<tr>\n<td><code v-pre>l</code></td>\n<td>7</td>\n</tr>\n<tr>\n<td><code v-pre>n</code></td>\n<td>8</td>\n</tr>\n<tr>\n<td><code v-pre>o</code></td>\n<td>7</td>\n</tr>\n<tr>\n<td><code v-pre>r</code></td>\n<td>0</td>\n</tr>\n<tr>\n<td><code v-pre>s</code></td>\n<td>2</td>\n</tr>\n<tr>\n<td><code v-pre>t</code></td>\n<td>2</td>\n</tr>\n<tr>\n<td><code v-pre>w</code></td>\n<td>22</td>\n</tr>\n<tr>\n<td><code v-pre>r_</code></td>\n<td>9</td>\n</tr>\n</tbody>\n</table>\n<hr>\n<h3 id=\"优缺点分析\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#优缺点分析\"><span>## 优缺点分析</span></a></h3>\n<ul>\n<li><strong>优点</strong>：\n<ul>\n<li>高效平衡了词汇表大小和编码步数。</li>\n<li>能够处理稀有词，避免OOV（Out of Vocabulary）问题。</li>\n</ul>\n</li>\n<li><strong>缺点</strong>：\n<ul>\n<li>基于贪婪算法，无法生成带概率的多种分词结果。</li>\n<li>解码时可能存在歧义问题，例如同一输入可对应多种分词方式。</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h2 id=\"常见错误与注意事项\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#常见错误与注意事项\"><span>常见错误与注意事项</span></a></h2>\n<p>⚠️ <strong>分词歧义问题</strong>：例如，&quot;Hello World&quot; 的分词结果可能出现多种形式，如 &quot;Hell/o/world&quot; 或 &quot;He/llo/world&quot;。</p>\n<p>⚠️ <strong>贪婪算法局限性</strong>：BPE仅考虑当前最优合并对，可能错过全局最优解。</p>\n<hr>\n<h2 id=\"行动清单\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#行动清单\"><span>行动清单</span></a></h2>\n<ul class=\"task-list-container\">\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" id=\"task-item-0\" checked=\"checked\" disabled=\"disabled\"><label class=\"task-list-item-label\" for=\"task-item-0\"> 实现一个简单的BPE算法，用于小型语料库测试。</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" id=\"task-item-1\" checked=\"checked\" disabled=\"disabled\"><label class=\"task-list-item-label\" for=\"task-item-1\"> 探索不同BPE参数（如词汇表大小）对模型性能的影响。</label></li>\n<li class=\"task-list-item\"><input type=\"checkbox\" class=\"task-list-item-checkbox\" id=\"task-item-2\" checked=\"checked\" disabled=\"disabled\"><label class=\"task-list-item-label\" for=\"task-item-2\"> 比较BPE与其他分词方法（如WordPiece）的实际效果。</label></li>\n</ul>\n<hr>\n<h2 id=\"思考-延伸问题\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#思考-延伸问题\"><span>[思考] 延伸问题</span></a></h2>\n<ol>\n<li>如何改进BPE算法，使其支持概率分词？</li>\n<li>在多语言模型中，BPE如何适配不同语言的特性？\n<ol>\n<li>\n<ul>\n<li>任务是跨语言迁移/翻译 → 建议 <strong>共享 BPE + 语言前缀</strong></li>\n</ul>\n</li>\n<li>如果是低资源语言建模 → 考虑 <strong>独立子词表</strong> 或 BBPE 分配资源更公平</li>\n</ol>\n</li>\n<li>以结合深度学习技术优化BPE的子词选择过程？</li>\n</ol>\n<hr>\n<blockquote>\n<p><strong>来源</strong>：本文内容摘自论文《Neural Machine Translation of Rare Words with Subword Units》，链接：<a href=\"https://arxiv.org/pdf/1508.07909\" target=\"_blank\" rel=\"noopener noreferrer\">https://arxiv.org/pdf/1508.07909</a></p>\n</blockquote>\n","tagOpen":"<template>","tagClose":"</template>"},"script":null,"scriptSetup":null,"scripts":[],"styles":[],"customBlocks":[]},"content":"## 元数据\n- **分类**：自然语言处理（NLP）\n- **标签**：BPE、分词算法、子词编码、自然语言处理、优化\n- **日期**：2025年4月1日  \n\n---\n\n\n\n## 核心观点概述\nByte Pair Encoding (BPE) 是一种常见的子词分词算法，通过逐步合并频率最高的字符对，生成一个高效的子词词表。它被广泛用于自然语言处理（NLP）任务中，尤其是在神经机器翻译（NMT）中，用以解决稀有词问题。\n\n💡 **启发点**：BPE通过贪婪算法逐步构建子词表，能够在词汇表大小和编码效率之间取得平衡。\n\n---\n\n\n\n## 重点内容提取\n\n### ## BPE的核心思想\n- BPE从一个基础的小型词表出发，不断合并频率最高的字符对，逐步生成新的子词单元。\n- 其目标是在子词粒度和词汇表大小之间找到平衡，使得模型既能高效编码，又能处理稀有词。\n\n\n### ## BPE的操作步骤\n1. **✅ 准备基础词表**：例如英文中包含26个字母及符号（如 `_` 表示单词结尾）。\n2. **⚠️ 拆分语料为最小单元**：将训练语料中的单词拆解为单个字符。\n3. **❗️ 统计频率并合并**：找到语料中频率最高的相邻字符对，并将其合并为新的子词。\n4. **重复迭代**：直到达到预设的子词表大小或频率阈值。\n\n---\n\n\n### ## 示例：从语料库中生成子词表\n以下是一个简单的BPE操作示例。\n\n#### 初始语料库（带频次）\n| 词频 | 单词        |\n|------|-------------|\n| [5]  | low_        |\n| [2]  | lowest_     |\n| [6]  | newer_      |\n| [3]  | wider_      |\n| [2]  | new_        |\n\n\n#### 基础字符频次统计\n| 字符 | 频次 |\n|------|------|\n| `_`  | 18   |\n| `d`  | 3    |\n| `e`  | 19   |\n| `i`  | 3    |\n| `l`  | 7    |\n| `n`  | 8    |\n| `o`  | 7    |\n| `r`  | 9    |\n| `s`  | 2    |\n| `t`  | 2    |\n| `w`  | 22   |\n\n\n#### 第一次迭代：合并频率最高的字符对\n- 合并 `r` 和 `_`，形成新子词 `r_`，更新后的频次为9。\n- 更新后的字符频次表：\n  \n| 字符 | 频次 |\n|------|------|\n| `_`  | 9    |\n| `d`  | 3    |\n| `e`  | 19   |\n| `i`  | 3    |\n| `l`  | 7    |\n| `n`  | 8    |\n| `o`  | 7    |\n| `r`  | 0    |\n| `s`  | 2    |\n| `t`  | 2    |\n| `w`  | 22   |\n| `r_` | 9    |\n\n---\n\n\n### ## 优缺点分析\n- **优点**：\n    - 高效平衡了词汇表大小和编码步数。\n    - 能够处理稀有词，避免OOV（Out of Vocabulary）问题。\n- **缺点**：\n    - 基于贪婪算法，无法生成带概率的多种分词结果。\n    - 解码时可能存在歧义问题，例如同一输入可对应多种分词方式。\n\n---\n\n\n\n## 常见错误与注意事项\n⚠️ **分词歧义问题**：例如，\"Hello World\" 的分词结果可能出现多种形式，如 \"Hell/o/world\" 或 \"He/llo/world\"。\n\n⚠️ **贪婪算法局限性**：BPE仅考虑当前最优合并对，可能错过全局最优解。\n\n---\n\n\n\n## 行动清单\n- [x] 实现一个简单的BPE算法，用于小型语料库测试。\n- [x] 探索不同BPE参数（如词汇表大小）对模型性能的影响。\n- [x] 比较BPE与其他分词方法（如WordPiece）的实际效果。\n\n---\n\n\n\n## [思考] 延伸问题\n1. 如何改进BPE算法，使其支持概率分词？\n2. 在多语言模型中，BPE如何适配不同语言的特性？\n\t1. - 任务是跨语言迁移/翻译 → 建议 **共享 BPE + 语言前缀**\n\t2. 如果是低资源语言建模 → 考虑 **独立子词表** 或 BBPE 分配资源更公平\n3.  以结合深度学习技术优化BPE的子词选择过程？\n\n---\n\n> **来源**：本文内容摘自论文《Neural Machine Translation of Rare Words with Subword Units》，链接：[https://arxiv.org/pdf/1508.07909](https://arxiv.org/pdf/1508.07909)","excerpt":"","includedFiles":[],"tasklistId":3,"title":"","headers":[{"level":2,"title":"元数据","slug":"元数据","link":"#元数据","children":[]},{"level":2,"title":"核心观点概述","slug":"核心观点概述","link":"#核心观点概述","children":[]},{"level":2,"title":"重点内容提取","slug":"重点内容提取","link":"#重点内容提取","children":[{"level":3,"title":"## BPE的核心思想","slug":"bpe的核心思想","link":"#bpe的核心思想","children":[]},{"level":3,"title":"## BPE的操作步骤","slug":"bpe的操作步骤","link":"#bpe的操作步骤","children":[]},{"level":3,"title":"## 示例：从语料库中生成子词表","slug":"示例-从语料库中生成子词表","link":"#示例-从语料库中生成子词表","children":[]},{"level":3,"title":"## 优缺点分析","slug":"优缺点分析","link":"#优缺点分析","children":[]}]},{"level":2,"title":"常见错误与注意事项","slug":"常见错误与注意事项","link":"#常见错误与注意事项","children":[]},{"level":2,"title":"行动清单","slug":"行动清单","link":"#行动清单","children":[]},{"level":2,"title":"[思考] 延伸问题","slug":"思考-延伸问题","link":"#思考-延伸问题","children":[]}]}}
